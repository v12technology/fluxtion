---
title: Core technology
has_children: true
nav_order: 3
published: true
---

# Introduction

Fluxtion is a DI container that combines dependency injection with event dispatch for realtime data processing.
The Fluxtion container can be thought of as a spreadsheet on steroids, each bean is like a formula cell, if any input
to the formula changes the spreadsheet forces a recalculation. As the container receives an event Fluxtion evaluates
which beans are connected to the handler and only triggers the connected beans for recalculation.

Following the spreadsheet analogy, the programmer provides the formula cells and immediate dependencies. The spreadsheet
calculates the global set of dependencies and manages the recalculation of formulas when any cell is updated. Delegating
the mechanical but difficult task of calculating global dependencies to an algorithm allows us to build spreadsheets
that are complex but very predictable. Enabling non programmers to solve computational problems that would be out of
their reach without the support of the spreadsheet engine.

Fluxtion brings this spreadsheet like paradigm and efficiency benefits to the realtime processing world. Methods on
beans are the formula cells, references between beans are the formula dependencies. The Fluxtion dependency analyser
uses the dependency information to calculate the global set of dependencies. When any bean is updated from an external
event dependent recalculation methods are called.

With Fluxtion a single junior developer can build and maintain event driven logic that would have previously required a
team of specialist experienced developers
{: .info }

## Key terms

| Term                 | Description                                                                                                                                     |
|----------------------|-------------------------------------------------------------------------------------------------------------------------------------------------|
| Event                | An event is any valid java instance that is submitted to the event processor                                                                    |
| Stream               | A stream is a set of events                                                                                                                     |
| EventProcessor       | Processes the event stream with user defined logic. An EventProcessor instance is generated by Fluxtion                                         |
| DI container         | interchangeable term for EventProcessor                                                                                                         |
| Node                 | A pojo instance that is managed within an EventProcessor                                                                                        |
| Managed bean         | interchangeable term for node                                                                                                                   |
| Event propagation    | Invoking methods in a topological order on nodes within an EventProcessor                                                                       |
| Event handler method | A method on a node that is an entry point for processing an external event                                                                      |
| Trigger method       | A method on a node that is triggered once all parent nodes have completed their trigger methods                                                 |
| Event notification   | Trigger or event handler methods notify a change by returning a boolean flag to control event propagation                                       |
| Graph space          | Construction of the meta model occurs in graph space, before generating the EventProcessor and after the user has provided all node information |

In formal terms Fluxtion can be classified as a combination of incremental computation and data flow programming.

## Event sourcing

If an event sourcing architectural style is followed the application behaviour will be completely reflected in the
test environment. Data driven clocks and audit logs tracing method call stacks are supported, when combined with event
replay this gives the developer a powerful and easy to use toolset for supporting a deployed system.

## Fluxtion dependencies

<div class="tab">
  <button class="tablinks" onclick="openTab(event, 'Maven')" id="defaultOpen">Maven</button>
  <button class="tablinks" onclick="openTab(event, 'Gradle')">Gradle</button>
</div>
<div id="Maven" class="tabcontent">
<div markdown="1">
{% highlight xml %}
    <dependencies>
        <dependency>
            <groupId>com.fluxtion</groupId>
            <artifactId>runtime</artifactId>
            <version>{{site.fluxtion_version}}</version>
        </dependency>
        <dependency>
            <groupId>com.fluxtion</groupId>
            <artifactId>compiler</artifactId>
            <version>{{site.fluxtion_version}}</version>
        </dependency>
    </dependencies>
{% endhighlight %}
</div>
</div>
<div id="Gradle" class="tabcontent">
<div markdown="1">
{% highlight groovy %}
implementation 'com.fluxtion:runtime:{{site.fluxtion_version}}'
implementation 'com.fluxtion:compiler:{{site.fluxtion_version}}'
{% endhighlight %}
</div>
</div>

### Dependency description

| Fluxtion dependency | Example use                             | Description                                           | 3rd party<br/> dependencies |
|---------------------|-----------------------------------------|-------------------------------------------------------|-----------------------------|
| Compiler            | Fluxtion#interpret<br/>Fluxtion#compile | Generates the EventProcessor <br/> from a description | Many                        |
| Runtime             | EventProcessor#onEvent                  | Runtime dispatch of events and helper libraries       | None                        |

It is possible to use one of the [Fluxtion]({{site.fluxtion_src_compiler}}/Fluxtion.java) compileAOT methods to generate an
EventProcessor ahead of time. An aot generated event processor only requires the runtime library on the classpath. In
this case set the scope of the compiler dependency to provided in maven.


# Event dispatch
Notification connections between beans are calculated at construction time using the same data that is used to add beans
to the DI container and annotations that mark recalculation methods.

When the proxy event handler method is called on the container it dispatches with the following with logic:

- Any top level event handler is invoked with the arguments provided
- The event handler method indicates whether child instances should be notified with a Boolean return type
- Any child reference defined in the DI structure is conditionally notified of the parent event handler completing
  processing
- A child instance can only be notified if all of its parents have finished processing their notifications
- The trigger method of the child returns a Boolean indicating whether the event notification should propagate
- The container recursively works through the child references and trigger methods in the container
- Dispatch callbacks are in strict topological order, with the event handler the root of the call tree
- Each instance is guaranteed to be invoked at maximum once per event processing cycle
- Any instances not connected to an executing root event handler will not be triggered in the cycle
- Connections can be either direct or through a reference chain

# Processing events in a stream processor

There are three main steps to building and running a stream processor application using Fluxtion

## Step 1: Describe processing logic

Describe the values that are calculated and actions invoked in response to an incoming event. Fluxtion provides two
api's to describe the processing logic:

1. [A set of annotations]({{site.fluxtion_src_runtime}}/annotations)
   that mark members of user written classes as being managed by the event processor
2. [A java 8 stream like api]({{site.fluxtion_src_compiler}}/builder/stream)
   , that can describe processing with a fluent functional style

## Step 2: Build the event processor container

Fluxtion provides a eventProcessorGenerator that converts the description into an executable
[EventProcessor]({{site.fluxtion_src_runtime}}/EventProcessor.java)
instance. The eventProcessorGenerator
is invoked from
[Fluxtion]({{site.fluxtion_src_compiler}}/Fluxtion.java)
with one of two utility methods:

1. **compile**: this generates a java source code version of the EventProcessor. The file is compiled in process and
   used
   to handle events. Total nodes are limited to the number of elements a source file can handle
2. **interpret**: Creates an in memory model of the processing backed with data structures. Can support millions of
   nodes

## Step 3: Process events

Once the
[EventProcessor]({{site.fluxtion_src_runtime}}/EventProcessor.java)
has been generated the instance is ready to consume events. The EventProcessor has a lifecycle so **init must be called
before sending any events for processing**.

The application pulls events from any source and invokes ```EventProcessor#onEvent```

![](../../images/integration-overview.png)


<script>
document.getElementById("defaultOpen").click();
</script>